# jdk
线程工作内存 主内存
read
load

use
asign

store
write

read>load不能保证获取的是最新的共享数据
synchronize(对象) 只有持有该对象的监视器(锁,引用) 才能进入方法|代码块
同步代码由于要对每一个线程判断是否持有锁,是非常消耗性能的,
所以使用过程中synchronize含括的范围越小越好
其中被称为锁的对象不应该跟共享属性是同一对象

volatile
实现
防止重排序
实例化一个对象 
1分配内存空间,
2初始化对象
3将内存空间的地址赋值给对应的引用
由于操作系统可以对指令进行重排序,所以上面的过程也可能会变成如下过程
1:分配内存空间
2将内存空间的地址赋值给对应的引用
3:实例化对象
如果是这个流程,多线程环境下就可能将一个未初始化的对象引用暴露出来,从而导致不可预料的结果,
可见性
线程工作内存改变共享变量强制刷新到主内存中
其他线程工作内存中该变量无效需要从新从主内存加载
只能保证 读或者写的原子性 对于i++这种 只能不能使用其做同步

jps 查看java进程
jstack查看java堆栈